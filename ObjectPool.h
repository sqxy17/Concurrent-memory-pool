#pragma once



//前言：我们知道申请内存使用的是malloc，但是正是因为什么场景下申请空间都是malloc，也就意味着它不会有很高的性能
//下面就是先设计一个定长的内存池，也是为为了后面的高并发内存池做一个铺垫，先熟悉一下简单内存池是如何控制的，第二他会作为我们后面内存池的一个基础组件

//我们申请的空间不能够一点一点还给系统，如果还也是把提前申请的一大块空间全部还给系统

//1.固定大小的内存申请释放需求 特点：
//ps1:性能达到极致
//ps2：不用考虑内存碎片等问题

//2.设计框架
//ps1：用一个指针指向申请的大块内存
//ps2：将程序中释放的空间用一个链表进行连接      ----注意，释放的空间是还给内存池的

//3.此处的设计是一个定长的内存池，为什么叫objectpool是因为针对某种对象的，对象就是定长的

#include"Common.h"
using std::bad_alloc;






//定长内存池有两种定义方式，但是为了后面的适配，还是建议像下面一样的使用方式                 ----另外一种方式就是这样template<size_t N>
template<class T>//也就是说，这个内存池每次获取的都是一个对象，因为对象的大小是固定的，也就是固定的大小的内存
class ObjectPool
{
public:

    //-------------------------------------成员函数:申请出一个 T 类型大小的对象-----------------------------------------------

    T* New()//这个函数的目的就是返回一个固定大小对象的指针，对象的大小和传的自定义类型T有关，函数的名字就是New（）
    {
       
        T* obj = nullptr;//先定义这个指针等着后续的备用
        //对象申请空间,首先用还回来的空间
        if (_freeList)
        {
            void* next = *((void**)_freeList);//_freeList代表的是头个还回来的结点,其前 4(8)个字节中存放着下一个结点的地址(没有就是 nullptr)
            obj = (T*)_freeList;//指针和指针所指向的空间要分清,这里的等于是 obj 指向了_freeList 指向的空间,对obj解引用也只是操作T类型大小字节
            _freeList = next;//_freeList 指向了新的空间
            return obj;
        }
        else
        {
            if (_remainBytes < sizeof(T))//这个判断是剩余内存不够一个对象大小时,则重新开大块空间
            {
                _remainBytes = 128 * 1024;//单位是字节,申请了128kb
                //                _memory = (char *) malloc(_remainBytes);
                _memory = (char*)SystemAlloc(_remainBytes >> 13);//2的 10 次方是 1k,8k 就是 2 的 13 次方             ---systemalloc  里面封装的是 virtualalloc
                if (_memory == nullptr) {
                    throw bad_alloc();//bad_alloc是标准库中的一个异常类,如果分配内存失败,则会抛出一个 bad_alloc类型的异常
                }
            }

            obj = (T*)_memory;//申请完大块的内存了,就让 obj 指向这块内存的开始,然后 char* _memory执行切割后的地址,也就是切完 T 类型大小后的末尾地址.
            size_t objSize = sizeof(T) < sizeof(void*) ? sizeof(void*) : sizeof(T);//这句是为了类型的大小还没有指针类型大       --单位就是字节数
            _memory += objSize;//让这个指针指向切割后的地址
            _remainBytes -= objSize;//注意考虑到字节不够的情况(自己剩余的还有,但是不够 T 大小申请的)
        }
        //定位 new,显式的调用 T 的构造函数初始化    ----对一块已经有的空间进行初始化        构造函数初始化
        new(obj)T;
       
        return obj;
    }






    //------------------------------------------------成员函数:用来处理换还回来的内存-----------------------------------------
    //ps1:要考虑到还回来的空间是不是小于 4 字节(32 位),
    void Delete(T* obj)//还回来的是对象类型的指针
    {
   
        obj->~T();//对一块已经存在的空间显式的去调用析构函数
        //请注意,32 位的指针和 64 位的指针大小是不一样的,将 obj 转换成二级指针,在解引用成为一级指针,此时无论指针大小是 4 还是 8 都能指向下一个地址.这样处理无论是 32 位还是 64 位都可以使用该程序
        *(void**)obj = _freeList;//还回来的新的对象指向原有的结点并替换头位置
        _freeList = obj;
     

    }




   
private:
    char* _memory = nullptr;//memory内存      用char类型就比较方便对申请的内存池进行切分，因为1个字节     _memory 是指向那个大块内存的指针

    size_t _remainBytes = 0;//这个变量是用来保存开辟的那一大块空间的剩余字节

    //ps1:分配的时候很好分配，但是还回来的空怎么处理？比如使用了50字节空间，还了20字节空间？
    //ps1_1:解决方式就是创建一个自由链表：前一个还回来的内存块的头4（8）个字节用来保存下一个还回来的内存块的地址
    void* _freeList = nullptr;//还回来过程中链接的自由链表的头指针


};
//注意点:
//ps1:刚开始_meeory 和 _freeList都是空的,所以刚开始肯定是要给_memory整上一个大块的内存

//ps2:如果 T 类型是一个 int 或者 char 怎么办?类型的大小可能比指针所占用的字节还要小,那这个类型所占用的空间如何保存地址呢?
//解决方式就是不满指针大小的给一个指针大小的空间,和指针大小相等或者大于指针大小的类型给原有大小的空间

//ps3:既然我们的项目是一个内存池,malloc 也是一个内存池,那为什么不直接向操作系统去申请空间呢(也就是直接去找堆,按页为单位去申请内存)
//在 windows 下使用的是 VirtualAlloc函数     ---这个函数是一个 windows 接口函数,该函数的功能是在调用进程的虚地址空间,预定或者提交一部分页
//linux 函数的 api 函数和 window 下的不一样,注意区分

//ps4:这个接口函数的声明
/*
LPVOID VirtualAlloc{
        LPVOID lpAddress, // 要分配的内存区域的地址
        DWORD dwSize, // 分配的大小
        DWORD flAllocationType, // 分配的类型
        DWORD flProtect // 该内存的初始保护属性
};
 */


 //ps5:自己申请的空间不用还,只要进程结束整个进程地址空间都会还给系统

















